"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listPR = exports.listEvents = exports.getMatchupMatches = exports.getMatchupPlacements = exports.getMatchup = exports.searchPlayers = exports.getPlayerRecentLegend = exports.getPlayerLegends = exports.getPlayerMatches = exports.getPlayerPlacements = exports.getPlayerPR = exports.getPlayerTeammates = exports.getPlayerByBrawlhallaId = exports.getPlayer = exports.overrideAPIURL = void 0;
require("isomorphic-fetch");
let API_URL = 'https://api.brawltools.com/v1';
const overrideAPIURL = (url) => {
    API_URL = url;
};
exports.overrideAPIURL = overrideAPIURL;
const uri = (path) => API_URL + path;
const runQuery = async (endpoint, params = {}) => {
    var _a;
    const uriWithParams = new URL(uri(endpoint));
    for (const [key, value] of Object.entries(params)) {
        if (value !== null && value !== undefined && value !== '') {
            uriWithParams.searchParams.append(key, value.toString());
        }
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => { controller.abort(); }, 5000);
    try {
        const response = await fetch(uriWithParams.href, { signal: controller.signal });
        if (!response.ok && response.status !== 404) {
            let errorMessage = `Fetch failed with status: ${response.status}`;
            // Try to extract a more specific error message from the API response, if available.
            try {
                const errorData = await response.json();
                errorMessage = (_a = errorData.message) !== null && _a !== void 0 ? _a : errorMessage;
            }
            catch (err) {
                // The response is not a valid JSON or doesn't have a message property.
                // Use the default error message.
            }
            throw new Error(errorMessage);
        }
        return response;
    }
    catch (error) {
        if (error.name === 'AbortError') {
            throw new Error('Request timed out after 5000ms');
        }
        throw error;
    }
    finally {
        clearTimeout(timeoutId);
    }
};
/**
   * Fetch a player's info by smashId
   * Returns - smashId, brawlhallaId, name
   */
const getPlayer = async (params) => {
    var _a;
    try {
        const res = await runQuery(`/player/${params.smashId}`);
        if (res.status === 404) {
            return null;
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player information.';
        throw new Error(errorMessage);
    }
};
exports.getPlayer = getPlayer;
/**
       * Fetch a player's info by brawlhallaId.
       * Returns - smashId, brawlhallaId, name
       */
const getPlayerByBrawlhallaId = async (params) => {
    var _a;
    try {
        const res = await runQuery(`/player/bhId/${params.brawlhallaId}`);
        if (res.status === 404) {
            return null;
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player information';
        throw new Error(errorMessage);
    }
};
exports.getPlayerByBrawlhallaId = getPlayerByBrawlhallaId;
/**
   * Fetch a player's teammates. SmashId is required.
   */
const getPlayerTeammates = async (params) => {
    var _a;
    try {
        const res = await runQuery('/player/teammate', { smashId: params.smashId, isOfficial: params.isOfficial, maxResults: params.maxResults, nextToken: params.nextToken });
        if (res.status === 404) {
            return { playerTeammates: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player teammates';
        throw new Error(errorMessage);
    }
};
exports.getPlayerTeammates = getPlayerTeammates;
/**
   * Fetch a player's PR information.
   */
const getPlayerPR = async (params) => {
    var _a;
    try {
        const res = await runQuery('/player/pr', {
            entrantSmashIds: params.entrantSmashId,
            gameMode: params.gameMode
        });
        if (res.status === 404) {
            return null;
        }
        // const key = gameMode === 1 ? "pr1v1" : "pr2v2";
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player PR.';
        throw new Error(errorMessage);
    }
};
exports.getPlayerPR = getPlayerPR;
/**
   * Fetch a player's placements in tournaments by game mode. Entrant ids and game mode is required.
   */
const getPlayerPlacements = async (params) => {
    var _a;
    try {
        const res = await runQuery('/player/placement', {
            entrantSmashIds: params.entrantSmashIds.join(','),
            isOfficial: params.isOfficial,
            gameMode: params.gameMode,
            nextToken: params.nextToken,
            maxResults: params.maxResults
        });
        if (res.status === 404) {
            return { playerPlacements: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player tournament history';
        throw new Error(errorMessage);
    }
};
exports.getPlayerPlacements = getPlayerPlacements;
/**
   * Fetch a player's matches in the given event slug.
   */
const getPlayerMatches = async (params) => {
    var _a;
    try {
        const res = await runQuery('/player/match', {
            eventSlug: params.slug,
            entrantSmashIds: params.entrantSmashIds.join(',')
        });
        if (res.status === 404) {
            return { playerMatches: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player event matches.';
        throw new Error(errorMessage);
    }
};
exports.getPlayerMatches = getPlayerMatches;
/**
   * Fetch all of a player's legends in a given year. Smash id is required.
   */
const getPlayerLegends = async (params) => {
    var _a;
    try {
        const res = await runQuery('/player/legend', {
            entrantSmashIds: params.entrantSmashIds.join(','),
            isOfficial: params.isOfficial,
            year: params.year,
            maxResults: params.maxResults,
            nextToken: params.nextToken
        });
        if (res.status === 404) {
            return { legends: [] };
        }
        return await res.json();
    }
    catch (e) {
        console.log(e);
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching player legends.';
        throw new Error(errorMessage);
    }
};
exports.getPlayerLegends = getPlayerLegends;
/**
   * Fetch a player's most recent legend with smash Id.
   */
const getPlayerRecentLegend = async (params) => {
    var _a;
    try {
        const res = await runQuery(`/player/${params.playerId}/legend`);
        if (res.status === 404) {
            return null;
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetchng player legend information.';
        throw new Error(errorMessage);
    }
};
exports.getPlayerRecentLegend = getPlayerRecentLegend;
/**
   * Search for a player. Query is required.
   */
const searchPlayers = async (params) => {
    var _a;
    try {
        const res = await runQuery('/player/search', {
            query: params.query,
            nextToken: params.nextToken,
            maxResults: params.maxResults
        });
        if (res.status === 404) {
            return { searchPlayers: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when searching for player.';
        throw new Error(errorMessage);
    }
};
exports.searchPlayers = searchPlayers;
/**
   * Fetch matchup between players. Entrant1SmashId and game mode are required.
   */
const getMatchup = async (params) => {
    var _a, _b, _c, _d;
    try {
        const res = await runQuery('/matchup', {
            isOfficial: params.isOfficial,
            entrant1SmashIds: params.entrant1SmashIds.join(','),
            entrant2SmashIds: (_a = params.entrant2SmashIds) === null || _a === void 0 ? void 0 : _a.join(','),
            gameMode: params.gameMode,
            nextToken: params.nextToken,
            maxResults: params.maxResults
        });
        if (res.status === 404) {
            return { matchups: [] };
        }
        const matchup = await res.json();
        return matchup;
    }
    catch (e) {
        if (((_b = e.response) === null || _b === void 0 ? void 0 : _b.status) === 400) {
            return { matchups: [] };
        }
        const errorMessage = (_c = e.message) !== null && _c !== void 0 ? _c : `Error fetching player matchup ${params.entrant1SmashIds.concat((_d = params.entrant2SmashIds) !== null && _d !== void 0 ? _d : []).join(', ')}`;
        throw new Error(errorMessage);
    }
};
exports.getMatchup = getMatchup;
/**
   * Fetch placement info for matchup between given players. Both entrant smash Ids and game mode are required.
   */
const getMatchupPlacements = async (params) => {
    var _a;
    try {
        const res = await runQuery('/matchup/placement', {
            isOfficial: params.isOfficial,
            entrant1SmashIds: params.entrant1SmashIds.join(','),
            entrant2SmashIds: params.entrant2SmashIds.join(','),
            gameMode: params.gameMode,
            nextToken: params.nextToken
        });
        if (res.status === 404) {
            return { matchupPlacements: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching matchup placements.';
        throw new Error(errorMessage);
    }
};
exports.getMatchupPlacements = getMatchupPlacements;
/**
   * Fetch match info for matchup between given players. Entrant1SmashIds is required.
   */
const getMatchupMatches = async (params) => {
    var _a, _b;
    try {
        const res = await runQuery('/matchup/match', {
            eventSlug: params.eventSlug,
            entrant1SmashIds: params.entrant1SmashIds.join(','),
            entrant2SmashIds: (_a = params.entrant2SmashIds) === null || _a === void 0 ? void 0 : _a.join(',')
        });
        if (res.status === 404) {
            return { matchupMatches: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_b = e.message) !== null && _b !== void 0 ? _b : 'Error when fetching matchup matches.';
        throw new Error(errorMessage);
    }
};
exports.getMatchupMatches = getMatchupMatches;
/**
   * Fetch all events in a given game mode. Game mode is required.
   */
const listEvents = async (params) => {
    var _a;
    try {
        const res = await runQuery('/event', {
            gameMode: params.gameMode,
            year: params.year,
            nextToken: params.nextToken,
            maxResults: params.maxResults,
            isOfficial: params.isOfficial
        });
        if (res.status === 404) {
            return { tournaments: [] };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching events list';
        throw new Error(errorMessage);
    }
};
exports.listEvents = listEvents;
/**
   * Fetch all PRs for a given game mode and region, required.
   */
const listPR = async (params) => {
    var _a;
    try {
        const res = await runQuery('/pr', {
            gameMode: params.gameMode,
            region: params.region,
            page: params.page,
            maxResults: params.maxResults,
            orderBy: params.orderBy
        });
        if (res.status === 404) {
            return { prPlayers: [], totalPages: 1 };
        }
        return await res.json();
    }
    catch (e) {
        const errorMessage = (_a = e.message) !== null && _a !== void 0 ? _a : 'Error when fetching PR list.';
        throw new Error(errorMessage);
    }
};
exports.listPR = listPR;
